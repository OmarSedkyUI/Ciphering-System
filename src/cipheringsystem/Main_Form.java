package cipheringsystem;

import javax.swing.JOptionPane;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Omar
 */
public class Main_Form extends javax.swing.JFrame {

    /**
     * Creates new form Main_Form
     */
    public Main_Form() {
        initComponents();
        jLabel4.setVisible(false);
        jTextField4.setVisible(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        jLabel2 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();
        jTextField2 = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        jTextField3 = new javax.swing.JTextField();
        jButton2 = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        jRadioButton1 = new javax.swing.JRadioButton();
        jRadioButton2 = new javax.swing.JRadioButton();
        jRadioButton3 = new javax.swing.JRadioButton();
        jRadioButton4 = new javax.swing.JRadioButton();
        jRadioButton5 = new javax.swing.JRadioButton();
        jLabel4 = new javax.swing.JLabel();
        jTextField4 = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel2.setText("Key:");

        jLabel3.setText("Word After Process:");

        jLabel1.setText("Word:");

        jButton2.setText("Click To Decrypt");
        jButton2.setActionCommand("");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton1.setText("Click To Encrypt");
        jButton1.setActionCommand("");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        buttonGroup1.add(jRadioButton1);
        jRadioButton1.setText("Caesar Cipher");

        buttonGroup1.add(jRadioButton2);
        jRadioButton2.setText("Vigenere Cipher (Repeating Key)");

        buttonGroup1.add(jRadioButton3);
        jRadioButton3.setText("Vigenere Cipher (Auto Key)");

        buttonGroup1.add(jRadioButton4);
        jRadioButton4.setText("Hill Cipher");

        buttonGroup1.add(jRadioButton5);
        jRadioButton5.setText("Play Fair Algorithm");

        jLabel4.setText("New Key:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(53, 53, 53)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(62, 62, 62)
                        .addComponent(jRadioButton1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(24, 24, 24)
                                .addComponent(jRadioButton4)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jRadioButton5))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jRadioButton2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jRadioButton3))))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2)
                            .addComponent(jLabel3)
                            .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(46, 46, 46)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jTextField1)
                            .addComponent(jTextField2)
                            .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, 375, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jTextField4, javax.swing.GroupLayout.PREFERRED_SIZE, 375, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(56, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 155, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(27, 27, 27)
                .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 155, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(115, 115, 115))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(49, 49, 49)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jRadioButton1)
                    .addComponent(jRadioButton2)
                    .addComponent(jRadioButton3))
                .addGap(5, 5, 5)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jRadioButton5)
                    .addComponent(jRadioButton4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(24, 24, 24)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jTextField4, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // TODO add your handling code here:
        jLabel4.setVisible(false);
        jTextField4.setVisible(false);
        if(jRadioButton1.isSelected())
        {
            if(jTextField2.getText().length()==1)
            {
                String Message;
                int ShiftNum=AlphabeticKey.AlphabetKey(jTextField2.getText().charAt(0));
                Message = CaesarCipher.Decrypt(jTextField1.getText(),ShiftNum);
                jTextField3.setText(Message);
            }
            else
            {
                JOptionPane.showMessageDialog(this,"Incorrect Key Size","Error",JOptionPane.ERROR_MESSAGE);
            }
        }
        else if(jRadioButton2.isSelected())
        {
            String Message;
            RepeatingKey.RepeatingKey2(jTextField2.getText(),jTextField1.getText());
            Message = VigenereCipher.Decryption(RepeatingKey.message, RepeatingKey.mappedkey);
            jTextField3.setText(Message);
        }
        else if(jRadioButton3.isSelected())
        {
            String Message;
            AutoKey.AutoKey2(jTextField2.getText(),jTextField1.getText());
            Message = VigenereCipher.Decryption(AutoKey.message, AutoKey.mappedkey);
            jTextField3.setText(Message);
        }
        else if(jRadioButton4.isSelected())
        {
            if(jTextField2.getText().length()==(jTextField1.getText().length()*jTextField1.getText().length()))
            {
                HillCipher.N = jTextField1.getText().length();
                String Message;
                Message = HillCipher.Decrypt(jTextField1.getText(), jTextField2.getText());
                if(Message.equals("FALSE"))
                {
                    JOptionPane.showMessageDialog(this,"NO INVERSE","Error",JOptionPane.ERROR_MESSAGE);
                }
                else
                {
                    jTextField3.setText(Message);
                }
            }
            else
            {
                JOptionPane.showMessageDialog(this,"Incorrect Key Size","Error",JOptionPane.ERROR_MESSAGE);
            }
        }
        else if(jRadioButton5.isSelected())
        {
            String textFieldValue1 = jTextField1.getText();
            String textFieldValue2 = jTextField2.getText();
            String NewMessage = PlayFairEncryption.CreateKeyTable(textFieldValue1, textFieldValue2);
            String Message = PlayFairEncryption.Decrypt(NewMessage.toCharArray(), PlayFairEncryption.mainArray);
            jTextField3.setText(Message);
        }
        else
        {
            JOptionPane.showMessageDialog(this,"Please Select An Algorithm","Error",JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        jLabel4.setVisible(false);
        jTextField4.setVisible(false);
        if(jRadioButton1.isSelected())
        {
            if(jTextField2.getText().length()==1)
            {
                String Message;
                int ShiftNum=AlphabeticKey.AlphabetKey(jTextField2.getText().charAt(0));
                Message = CaesarCipher.Encrypt(jTextField1.getText(),ShiftNum);
                jTextField3.setText(Message);
            }
            else
            {
                JOptionPane.showMessageDialog(this,"Incorrect Key Size","Error",JOptionPane.ERROR_MESSAGE);
            }
        }
        else if(jRadioButton2.isSelected())
        {
            String Message;
            RepeatingKey.RepeatingKey1(jTextField2.getText(),jTextField1.getText());
            Message = VigenereCipher.Encryption(RepeatingKey.message, RepeatingKey.mappedkey);
            jTextField3.setText(Message);
        }
        else if(jRadioButton3.isSelected())
        {
            String Message;
            String NewKey;
            NewKey = AutoKey.AutoKey1(jTextField2.getText(),jTextField1.getText());
            Message = VigenereCipher.Encryption(AutoKey.message, AutoKey.mappedkey);
            jTextField3.setText(Message);
            jLabel4.setVisible(true);
            jTextField4.setVisible(true);
            jTextField4.setText(NewKey);
        }
        else if(jRadioButton4.isSelected())
        {
            if(jTextField2.getText().length()==(jTextField1.getText().length()*jTextField1.getText().length()))
            {
                HillCipher.N = jTextField1.getText().length();
                String Message;
                Message = HillCipher.Encrypt(jTextField1.getText(), jTextField2.getText());
                jTextField3.setText(Message);
            }
            else
            {
                JOptionPane.showMessageDialog(this,"Incorrect Key Size","Error",JOptionPane.ERROR_MESSAGE);
            }
        }
        else if(jRadioButton5.isSelected())
        {
            String textFieldValue1 = jTextField1.getText();
            String textFieldValue2 = jTextField2.getText();
            String NewMessage = PlayFairEncryption.CreateKeyTable(textFieldValue1, textFieldValue2);
            String Message = PlayFairEncryption.encrypt(NewMessage.toCharArray(), PlayFairEncryption.mainArray);
            jTextField3.setText(Message);
        }
        else
        {
            JOptionPane.showMessageDialog(this,"Please Select An Algorithm","Error",JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Main_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Main_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Main_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Main_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Main_Form().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JRadioButton jRadioButton1;
    private javax.swing.JRadioButton jRadioButton2;
    private javax.swing.JRadioButton jRadioButton3;
    private javax.swing.JRadioButton jRadioButton4;
    private javax.swing.JRadioButton jRadioButton5;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField2;
    private javax.swing.JTextField jTextField3;
    private javax.swing.JTextField jTextField4;
    // End of variables declaration//GEN-END:variables
}

class Encryption
{
    /*
    This system is a ciphering system that is used to get the encryption and decryption using 5 algorithms that are:
    Caesar Cipher , Repeating Key Vigenere Chipher , Auto Key Vigenere Chipher , Hill Cipher and Play Fair Algorithm
    */
    String Message;
    String StrKey;
}

class AlphabeticKey extends Encryption
{
    public static int AlphabetKey(char Alphabets)
    {
        switch ( Alphabets)
        {
            case 'A':
            case 'a':
                return 0;
             case 'B':
             case 'b':
                 return 1;
             case 'C':
             case 'c':
                 return 2;
             case 'D':
             case 'd':
                 return 3;
             case 'E':
             case 'e':
                 return 4;
             case 'F':
             case 'f':
                 return 5;
             case 'G':
             case 'g':
                 return 6;
             case 'H':
             case 'h':
                 return 7;
             case 'I':
             case 'i':
                 return 8;
             case 'J':
             case 'j':
                 return 9;
             case 'K':
             case 'k':
                 return 10;
             case 'L':
             case 'l':
                 return 11;
             case 'M':
             case 'm':
                 return 12;
             case 'N':
             case 'n':
                 return 13;
             case 'O':
             case 'o':
                 return 14;
             case 'P':
             case 'p':
                 return 15;
             case 'Q':
             case 'q':
                return 16;
             case 'R':
             case 'r':
                 return 17;
             case 'S':
             case 's':
                 return 18;
             case 'T':
             case 't':
                 return 19;
             case 'U':
             case 'u':
                 return 20;
             case 'V':
             case 'v':
                 return 21;
             case 'W':
             case 'w':
                 return 22;
             case 'X':
             case 'x':
                 return 23;
             case 'Y':
             case 'y':
                 return 24;
             case 'Z':
             case 'z':
                 return 25;
             default:
                 return 0;
        }
    }
    
    public static char KeyAlphabet(int Keys)
    {
        switch (Keys)
        {
            case 0:
                return 'A';
             case 1:
                 return 'B';
             case 2:
                 return 'C';
             case 3:
                 return 'D';
             case 4:
                 return 'E';
             case 5:
                 return 'F';
             case 6:
                 return 'G';
             case 7:
                 return 'H';
             case 8:
                 return 'I';
             case 9:
                 return 'J';
             case 10:
                 return 'K';
             case 11:
                 return 'L';
             case 12:
                 return 'M';
             case 13:
                 return 'N';
             case 14:
                 return 'O';
             case 15:
                 return 'P';
             case 16:
                return 'Q';
             case 17:
                 return 'R';
             case 18:
                 return 'S';
             case 19:
                 return 'T';
             case 20:
                 return 'U';
             case 21:
                 return 'V';
             case 22:
                 return 'W';
             case 23:
                 return 'X';
             case 24:
                 return 'Y';
             case 25:
                 return 'Z';
             default:
                 return 0;
        }
    }
}

class CaesarCipher extends AlphabeticKey
{
    /*
    Encryption, the message is converted from string to character array and the key is converted from String to
    integar then the key is added to the message charcter array then we apply mod 26 to all elements in
    message array to get Character between A and Z then the character array is converted to string to
    get the encrypted message.
    Decryption, the message is converted from string to character array and the key is converted from String to
    integar then the key is subtracted from the message charcter array then we apply mod 26 to all elements in
    message array to get Character between A and Z then the character array is converted to string to
    get the message before encryption.
    */
    public static String Encrypt(String Message, int ShiftNum)
    {
        if(ShiftNum>26)
        {
            ShiftNum=ShiftNum%26;
        }
        if(ShiftNum<0)
        {
            ShiftNum=(ShiftNum%26) + 26;
        }
        String EMsg="";
        char letter;
        for(int i=0;i<Message.length(); i++)
        {
            letter=Message.toLowerCase().charAt(i);
            if(letter>='a' && letter<='z')
            {
                letter= (char) (letter + ShiftNum);
        
                if(letter>'z')
                {
                    letter=(char) (letter + 'a' - 'z' -1);
                }
            EMsg= EMsg+ letter;
            }
            else 
            {
                EMsg= EMsg+ letter;
            }
        }
        return EMsg;
    }
     
    public static String Decrypt(String Message, int ShiftNum)
    {
        if(ShiftNum>26)
        {
            ShiftNum=ShiftNum%26;
        }
        if(ShiftNum<0)
        {
            ShiftNum=(ShiftNum%26) + 26;
        }
        String DEMsg="";
        char letter;
        for(int i=0;i<Message.length(); i++)
        {
            letter=Message.toLowerCase().charAt(i);
            if(letter>='a' && letter<='z')
            {
                letter= (char) (letter - ShiftNum);
    
                if(letter<'a')
                {
                    letter=(char) (letter - 'a' + 'z' +1);
                }
                DEMsg= DEMsg+ letter;
            }
    
            else
            {
                DEMsg= DEMsg+ letter;
            }
        }
        return DEMsg;
    }
}

class VigenereCipher extends Encryption {
    /*
    Encryption, the message is converted from string to character array and the key is converted from String to
    character array then we sum the character that the index is pointing at in the message array with the character
    that the index is pointing at in the key array then we apply mod 26 to all elements in
    message array to get Character between A and Z then the character array is converted to string to
    get the encrypted message.
    Decryption, the message is converted from string to character array and the key is converted from String to
    integar then we subtract the character that the index is pointing at in the message array from the character
    that the index is pointing at in the key array then we apply mod 26 to all elements in
    message array to get Character between A and Z then the character array is converted to string to
    get the message before encryption.
    */
    public static String Encryption(String message, String mappedkey) {
        int [][]table =createvigenereTable();
        String encryptedtext = "";
        for(int i=0; i < message.length(); i++){
            if(message.charAt(i)== (char)32 && mappedkey.charAt(i)== (char)32){
                encryptedtext +=  " "; 
            }else{
                encryptedtext += (char)table[(int)message.charAt(i)-65][(int)mappedkey.charAt(i)-65];
            }
        }
        return encryptedtext;
    }

    public static int[][] createvigenereTable() {
        int [][]tableArr=new int[26][26];
        for(int i=0; i<26;i++){
            for(int j=0; j<26; j++){
                int temp;
                if((i+65)+j >90){
                    temp=((i+65)+j)-26;
                    tableArr[i][j]=temp;
                }else{
                    temp=(i+65)+j;
                    tableArr[i][j] = temp;
                }
            }
        }
        return tableArr;       
    }

    public static String Decryption(String message, String mappedkey) {
        int [][]table=createvigenereTable();
        String decryptedText = "";
        
        for(int i=0; i<message.length(); i++){
            if(message.charAt(i) == (char)32 && mappedkey.charAt(i) == (char)32){
                decryptedText +=" ";  
            }else{
                decryptedText += (char)(65 + itrCount((int)mappedkey.charAt(i), (int)message.charAt(i))) ;              
            }
        }
        return decryptedText;
    }

    public static int itrCount(int key, int msg) {
        int counter =0;
        String result = "";
        for (int i=0; i < 26; i++){
            if (key+i > 90){
                result += (char)(key+(i-26)); 
            } else{
                result += (char)(key+i);
            }
        }
        for (int i=0; i<result.length(); i++){
            if(result.charAt(i) == msg){
                break;
            }else{
                counter++;
            }
        }
        return counter;
    }    
}

class RepeatingKey extends VigenereCipher{
    /*
    Is used to get the Key for Repeating Key Vigenere Cipher.The Message Length is divided by the Key Length
    then rounded up to get the number of times we need to repeat the key.
    */
    public static String message;
    public static String mappedkey;
    
    public static void RepeatingKey1(String key,String msg){
        key=key.toUpperCase(); 
    
        msg=msg.toUpperCase();
   
        String test = msg;
        int len = test.replace(" ", "").length();
        int keylen = key.length();
        int noOfKey = (int) Math.ceil((float)len / keylen);
        String Newkey = key;
        for(int i= 0;i<(noOfKey-1);i++)
        {
            Newkey = Newkey+key;
        }
    
        String Keymap="";
        for(int i=0,j=0; i<msg.length(); i++){
            if(msg.charAt(i)==(char)32){
                Keymap += (char)32;
            }else{
                if(j < key.length()){
                    Keymap +=key.charAt(j);
                    j++;
                } else{
                    j=0;
                    Keymap += key.charAt(j);
                    j++;
                }  
            }
        }
        message=msg;
        mappedkey=Keymap;
    }
    public static void RepeatingKey2(String key,String msg){
        
        key=key.toUpperCase(); 
      
        msg=msg.toUpperCase();
   
        String test = msg;
        int len = test.replace(" ", "").length();
        int keylen = key.length();
        int noOfKey = (int) Math.ceil((float)len / keylen);
        String Newkey = key;
        for(int i= 0;i<(noOfKey-1);i++)
        {
            Newkey = Newkey+key;
        }
        String Keymap="";
        for(int i=0,j=0; i<msg.length(); i++){
            if(msg.charAt(i)==(char)32){
                Keymap += (char)32;
            }else{
                if(j < key.length()){
                    Keymap +=key.charAt(j);
                    j++;
            }else{
                    j=0;
                    Keymap += key.charAt(j);
                    j++;
                }
            }
        }
        message=msg;
        mappedkey=Keymap;
    }
}

class AutoKey extends VigenereCipher{
    /*
    Is used to get the Key for Auto Key Vigenere Cipher.The Message is appended to the Key
    to get the new key.
    */
    public static String message;
    public static String mappedkey;
    
    public static String AutoKey1(String key,String msg){
        String NewKey;
        key=key.toUpperCase(); 
    
        msg=msg.toUpperCase();
   
        key = key + msg;
        NewKey = key;
    
        String Keymap="";
        for(int i=0,j=0; i<msg.length(); i++){
            if(msg.charAt(i)==(char)32){
                Keymap += (char)32;
            }else{
                if(j < key.length()){
                    Keymap +=key.charAt(j);
                    j++;
                } else{
                    j=0;
                    Keymap += key.charAt(j);
                    j++;
                }  
            }
        }
        message=msg;
        mappedkey=Keymap;
        return NewKey;
    }
    public static void AutoKey2(String key,String msg){
        
        key=key.toUpperCase(); 
      
        msg=msg.toUpperCase();
   
        String Keymap="";
        for(int i=0,j=0; i<msg.length(); i++){
            if(msg.charAt(i)==(char)32){
                Keymap += (char)32;
            }else{
                if(j < key.length()){
                    Keymap +=key.charAt(j);
                    j++;
            }else{
                    j=0;
                    Keymap += key.charAt(j);
                    j++;
                }
            }
        }
        message=msg;
        mappedkey=Keymap;
    }
}

class HillCipher extends AlphabeticKey
{
    /*
    Encryption, the message is converted from string to character array then to integar array and the key is converted from String to
    character array then to integar array then to 2d integar array then the key 2d array is multiplied to the message integar array as
    a matrix then we apply mod 26 to all elements in array to get number between 0 and 25 then the integar array is converted to charater
    array then to string to get the encrypted message.
    Decryption, the message is converted from string to character array then to integar array and the key is converted from String to
    character array then to integar array then to 2d integar array then we get the inverse of the key then the inverse of the key is
    multiplied to the message integar array as a matrix then we apply mod 26 to all elements in array to get number between 0 and 25
    then the integar array is converted to charater array then to string to get the message before encryption.
    */
    static int N;
    public static void ChangeChartoInt(char[]arr1,int[]arr2)
    {
        for(int i=0;i<arr1.length;i++)
        {
            arr2[i] = AlphabetKey(arr1[i]);
        }
    }
    public static void Changeto2DArray(int[]arr1,int[][]arr2,int n)
    {
        for(int i=0; i<n;i++)
            for(int j=0;j<n;j++)
                arr2[i][j] = arr1[(i*n) + j];
    }
    public static void MultiplyMatrix(int[][]arr1,int[]arr2,int[]arr3,int n)
    {
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                arr3[i]+=(arr1[i][j]*arr2[j]);
            }
        }
    }
    public static void Mod26(int[]arr)
    {
        for(int i=0;i<arr.length;i++)
        {
            arr[i]=arr[i]%26;
        }
    }
    public static void ChangeInttoChar(int[]arr1,char[]arr2)
    {
        for(int i=0;i<arr1.length;i++)
        {
            arr2[i] = KeyAlphabet(arr1[i]);
        }
    }
    public static String Encrypt(String Message,String Key)
    {
        char[]MessageArr = Message.toCharArray();
        int[]MessageArr1 = new int[Message.length()];
        ChangeChartoInt(MessageArr, MessageArr1);
        char[]KeyArr = Key.toCharArray();
        int[]KeyArr1 = new int[Key.length()];
        ChangeChartoInt(KeyArr, KeyArr1);
        int[][]KeyArr2 = new int[Message.length()][Message.length()];
        Changeto2DArray(KeyArr1, KeyArr2, Message.length());
        int[]EncryptedMessage = new int[Message.length()];
        MultiplyMatrix(KeyArr2, MessageArr1, EncryptedMessage, Message.length());
        Mod26(EncryptedMessage);
        char[]EncryptedString = new char[Message.length()];
        ChangeInttoChar(EncryptedMessage, EncryptedString);
        String EncryptedMessageText = new String(EncryptedString);
        return EncryptedMessageText;
    }
    static void getCofactor(int A[][], int temp[][], int p, int q, int n) 
    { 
	int i = 0, j = 0; 

        for (int row = 0; row < n; row++) 
	{ 
            for (int col = 0; col < n; col++) 
            { 
		if (row != p && col != q) 
		{ 
                    temp[i][j++] = A[row][col]; 
                    if (j == n - 1) 
                    { 
                        j = 0; 
			i++; 
                    } 
		} 
            } 
	} 
    } 
    static int determinant(int A[][], int n) 
    { 
	int D = 0; 

        if (n == 1) 
            return A[0][0]; 

	int [][]temp = new int[N][N];

	int sign = 1;

	for (int f = 0; f < n; f++) 
	{ 
            getCofactor(A, temp, 0, f, n); 
            D += sign * A[0][f] * determinant(temp, n - 1); 

            sign = -sign; 
	} 

	return D; 
    } 

    static void adjoint(int A[][],int [][]adj) 
    { 
	if (N == 1) 
	{ 
		adj[0][0] = 1; 
		return; 
	} 

	int sign = 1; 
	int [][]temp = new int[N][N]; 

	for (int i = 0; i < N; i++) 
	{ 
            for (int j = 0; j < N; j++) 
            {
		getCofactor(A, temp, i, j, N); 

                sign = ((i + j) % 2 == 0)? 1: -1; 
		
                adj[j][i] = (sign)*(determinant(temp, N-1)); 
            } 
	} 
    } 
    static boolean inverse(int A[][], int [][]inverse) 
    { 
	int det = determinant(A, N); 
	if (det == 0) 
	{
            return false; 
	}
        
        det = det%26;
        if(det<0)
            det = det+26;
        
        boolean InverseDet = false;
        
        for (int x = 1; x < 26; x++)
        {
           if ((det * x) % 26 == 1)
           {
               det = x;
               InverseDet = true;
               break;
           }
           else
           {
               InverseDet = false;
           }
        }
        if(!InverseDet)
        {
            return false;
        }

	int [][]adj = new int[N][N]; 
	adjoint(A, adj); 
        
        for (int i = 0; i < N; i++) 
        {
            for (int j = 0; j < N; j++)
            {
                adj[i][j] = adj[i][j]%26;
                if(adj[i][j]<0)
                {
                    adj[i][j] = adj[i][j]+26;
                }
            }
        }
        
	for (int i = 0; i < N; i++) 
        {
            for (int j = 0; j < N; j++)
            {
                inverse[i][j] = adj[i][j]*det; 
                inverse[i][j] = inverse[i][j]%26;
                if(inverse[i][j]<0)
                {
                    inverse[i][j] = inverse[i][j]+26;
                }
            }
        }
	return true; 
    }
    public static String Decrypt(String Message,String Key)
    {
        char[]MessageArr = Message.toCharArray();
        int[]MessageArr1 = new int[Message.length()];
        ChangeChartoInt(MessageArr, MessageArr1);
        char[]KeyArr = Key.toCharArray();
        int[]KeyArr1 = new int[Key.length()];
        ChangeChartoInt(KeyArr, KeyArr1);
        int[][]KeyArr2 = new int[Message.length()][Message.length()];
        Changeto2DArray(KeyArr1, KeyArr2, Message.length());
        int[][]InverseKey = new int[Message.length()][Message.length()];
        if (inverse(KeyArr2, InverseKey))
        {
            int[]EncryptedMessage = new int[Message.length()];
            MultiplyMatrix(InverseKey, MessageArr1, EncryptedMessage, Message.length());
            Mod26(EncryptedMessage);
            char[]EncryptedString = new char[Message.length()];
            ChangeInttoChar(EncryptedMessage, EncryptedString);
            String EncryptedMessageText = new String(EncryptedString);
            return EncryptedMessageText;
        }
        else
        {
            return "FALSE";
        }
    }
}
class PlayFairEncryption extends Encryption
{
    /*
    The Playfair Cipher Encryption Algorithm:

    Generate the key Square(5×5):
    The key square is a 5×5 grid of alphabets that acts as the key for encrypting the plaintext.
    Each of the 25 alphabets must be unique and one letter of the alphabet (usually J) is omitted from
    the table (as the table can hold only 25 alphabets). If the plaintext contains J, then it is replaced
    
    Algorithm to encrypt the plain text: The plaintext is split into pairs of two letters (digraphs).
    If there is an odd number of letters, a Z is added to the last letter.
    If both the letters are in the same column: Take the letter below each one (going back to the top if at the bottom).
    If both the letters are in the same row: Take the letter to the right of each one (going back to the leftmost if at the rightmost position).
    If neither of the above rules is true: Form a rectangle with the two letters and take the letters on the horizontal opposite corner of the rectangle.
    
    Decrypting the Playfair cipher is as simple as doing the same process in reverse. The receiver has the same key and can create the same key table, and
    then decrypt any messages made using that key.
    Algorithm to decrypt the ciphertext: The ciphertext is split into pairs of two letters (digraphs).
    If both the letters are in the same column: Take the letter above each one (going back to the bottom if at the top)
    If both the letters are in the same row: Take the letter to the left of each one (going back to the rightmost if at the leftmost position).
    If neither of the above rules is true: Form a rectangle with the two letters and take the letters on the horizontal opposite corner of the rectangle
    */
    public static char[][] mainArray = new char[5][5];
 public static String CreateKeyTable(String Message,String Key)
 {
 try
        {
            boolean flag = false;
            char ch = 'z';
                
        Message= Message.toLowerCase();
        Message= Message.replaceAll("\\s", "");
        
        int len = Message.length();
        if(len %2 != 0)
        {
            Message+=ch;
        }
        
        for (int i =0; i<Message.length();i++)
        {
            if(!(Message.charAt(i)>='a' && Message.charAt(i)<='z')){
                flag = true;
            }
        }
        if(flag)
        {
            throw new Except("Enter characters only");
        }
        
        
        
        Key= Key.toLowerCase();
        Key= Key.replaceAll("\\s", "");
        
        len = Key.length();
        if(len > 25)
        {
            throw new Except("Enter smaller Key");
        }
        char[] cArray = Key.toCharArray();
        int k = 0;
        int i2 = 0;
        int j2 = 0;
        
        OuterLoop:for (int i =0; i< 5; i++)
        {
            i2 = i;
            for (int j=0; j<5; j++)
            {
                j2 = j;
                mainArray[i][j] = cArray[k];
                k=k+1;
                if(k==cArray.length)
                {
                    break OuterLoop;
                }
            }
        }
        
        j2++;
        flag = false;
        char t = 'a';
        for (int i =i2; i< 5; i++)
        {
            for (int j=j2; j<5; j++)
            {
                for (int count = 0; count < cArray.length; count++)
                {
                    if(t != cArray[count] && t != 'j')
                    {
                        flag = true;
                    }
                    else{flag = false;break;}
                }
                if(flag)
                {
                    mainArray[i][j] = t;
                    
                }
                else
                {
                    if(j==0)
                    {
                        i--;
                        j=4;
                    }
                    else
                    {
                        j--;
                    }
                }
                t++;
            }
            j2 = 0;
        }
        }
        catch(Except e)
        {
            JOptionPane.showMessageDialog(null,e.getMessage(),"Error",JOptionPane.ERROR_MESSAGE);
        }
 
 return Message;
 }
  public  static void findCharactersOfDigraph(char[][] KeyTable,char character1ToChangeToI,char character2ToChangeToI, int []arr)
    {
        if (character1ToChangeToI == 'j')
        { 
            character1ToChangeToI = 'i';
        } 
        else if(character2ToChangeToI== 'j')
        {
            character2ToChangeToI = 'i';
        }
       for(int counter1=0;counter1<5;counter1++)
       {
           for(int counter2=0;counter2<5;counter2++)
           {
               if(KeyTable[counter1][counter2] == character1ToChangeToI)
               {
                   arr[0]=counter1;
                   arr[1]=counter2;
               }
               else if(KeyTable[counter1][counter2] == character2ToChangeToI)
               {
                   arr[2]=counter1;
                   arr[3]=counter2;
               }
           }
       }
    }    
  public static String encrypt(char[] Str,char[][] KeyTable)
    {
        int[] array = new int[4];
        for(int count=0;count<Str.length;count+=2)
        {
            findCharactersOfDigraph(KeyTable,Str[count],Str[count+1],array);
            if(array[0]==array[2])
            {
                Str[count] = KeyTable[array[0]][(array[1]+1)%5];
                Str[count+1] = KeyTable[array[0]][(array[3]+1)%5];
            }
            else if(array[1]==array[3])
            {
               Str[count] = KeyTable[(array[0]+1)%5][array[1]];
               Str[count+1] = KeyTable[(array[2]+1)%5][array[1]]; 
            }
            else
            {
                Str[count] = KeyTable[array[0]][array[3]]; 
                Str[count + 1] = KeyTable[array[2]][array[1]];
            }
        }
        String Message = new String(Str);
        return Message;
    }
    public static String Decrypt(char[] Str,char[][] KeyTable)
    {
        int[] array = new int[4];
        for(int count=0;count<Str.length;count+=2)
        {
            findCharactersOfDigraph(KeyTable,Str[count],Str[count+1],array);
            if(array[0]==array[2])
            {
                Str[count] = KeyTable[array[0]][(array[1]+4)%5];
                Str[count+1] = KeyTable[array[0]][(array[3]+4)%5];
            }
            else if(array[1]==array[3])
            {
               Str[count] = KeyTable[(array[0]+4)%5][array[1]];
               Str[count+1] = KeyTable[(array[2]+4)%5][array[1]]; 
            }
            else
            {
                Str[count] = KeyTable[array[0]][array[3]]; 
                Str[count + 1] = KeyTable[array[2]][array[1]];
            }
        }
        String Message = new String(Str);
        return Message;
    }
    
}
class Except extends Exception
{
    public Except(String message)
    {
        super(message);
    }
}